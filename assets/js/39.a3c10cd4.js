(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{428:function(_,v,t){"use strict";t.r(v);var s=t(24),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"完全二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[_._v("#")]),_._v(" 完全二叉树")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("需要注意的是不要把完全二叉树和“满二叉树”搞混了，完全二叉树不要求所有树都有左右子树，但它要求：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("任何一个节点不能只有右子树没有左子树")])]),_._v(" "),t("li",[t("p",[_._v("叶子节点出现在最后一层或者倒数第二层，不能再往上")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/NyY6ajhkfSicdzIAVWQ2ib9VFD3Wj9a7xbibicVZZ511Ile3gykBqlGOvjuiaHLLhKQtGx022jfLC774yiaKZJpwdKgg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:""}})])])])])]),_._v(" "),t("h1",{attrs:{id:"二叉查找树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉查找树"}},[_._v("#")]),_._v(" 二叉查找树")]),_._v(" "),t("p",[t("strong",[_._v("二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义")]),_._v("。")]),_._v(" "),t("p",[_._v("根据二叉排序树这个特点我们可以知道："),t("strong",[_._v("二叉排序树的中序遍历一定是从小到大的")]),_._v("。")]),_._v(" "),t("h1",{attrs:{id:"平衡二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[_._v("#")]),_._v(" 平衡二叉树")]),_._v(" "),t("p",[_._v("平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：")]),_._v(" "),t("ol",[t("li",[_._v("平衡二叉树要么是一棵空树")]),_._v(" "),t("li",[_._v("要么保证左右子树的高度之差不大于 1")]),_._v(" "),t("li",[_._v("子树也必须是一颗平衡二叉树")])]),_._v(" "),t("h1",{attrs:{id:"b-树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[_._v("#")]),_._v(" B 树")]),_._v(" "),t("p",[_._v("它和平衡二叉树的不同有这么几点：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树")]),_._v("，M 阶 B 树表示该树每个节点最多有 M 个子树")]),_._v(" "),t("li",[_._v("平衡二叉树每个节点"),t("strong",[_._v("只有一个数据和两个指向孩子的指针")]),_._v("，而 B 树每中间节点"),t("strong",[_._v("有 k-1 个关键字（可以理解为数据）和 k 个子树")]),_._v("（ k 介于阶数 M 和 M/2 之间，M/2 向上取整）")]),_._v(" "),t("li",[t("strong",[_._v("B 树的所有叶子节点都在同一层")]),_._v("，并且叶子节点只有关键字，指向孩子的指针为 null")])]),_._v(" "),t("h1",{attrs:{id:"b-树-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树-2"}},[_._v("#")]),_._v(" B+ 树")]),_._v(" "),t("ol",[t("li",[_._v("节点的"),t("strong",[_._v("子树数和关键字数相同")]),_._v("（B 树是关键字数比子树数少一）")]),_._v(" "),t("li",[_._v("节点的关键字表示的是"),t("strong",[_._v("子树中的最大数")]),_._v("，在子树中同样含有这个数据")]),_._v(" "),t("li",[_._v("叶子节点包含了"),t("strong",[_._v("全部数据")]),_._v("，同时符合左小右大的顺序")])]),_._v(" "),t("p",[_._v("B+ 树的三个优点：")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("层级更低，IO 次数更少")])])]),_._v(" "),t("li",[t("p",[_._v("每次都需要"),t("strong",[_._v("查询到叶子节点")]),_._v("，查询"),t("strong",[_._v("性能稳定")])])]),_._v(" "),t("li",[t("p",[_._v("叶子节点形成"),t("strong",[_._v("有序链表")]),_._v("，范围查询方便")])])]),_._v(" "),t("h1",{attrs:{id:"红黑树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#红黑树"}},[_._v("#")]),_._v(" 红黑树")]),_._v(" "),t("h1",{attrs:{id:"mysql的索引底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql的索引底层原理"}},[_._v("#")]),_._v(" mysql的索引底层原理")]),_._v(" "),t("h3",{attrs:{id:"引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引擎"}},[_._v("#")]),_._v(" 引擎")]),_._v(" "),t("p",[t("strong",[_._v("MyISAM")])]),_._v(" "),t("p",[_._v("Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件 . B+树结构")]),_._v(" "),t("p",[_._v("Myisam 只支持表锁，且不支持事务。")]),_._v(" "),t("p",[t("strong",[_._v("InnoDB")])]),_._v(" "),t("p",[_._v("InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。")]),_._v(" "),t("p",[_._v("在InnoDB 中存在表锁和行锁，InnoDB 支持事务")]),_._v(" "),t("p",[_._v("因为InnoDB是按照主键聚集的，要是InnoDB没有主键就会找数据表中的位置标志的字段作为主键，要是没有这种字段就会隐世的生成唯一标识的主键，生成的主键默认为长整型，6个字节。")]),_._v(" "),t("p",[_._v("而MyISAM可以要求没有主键，这是这两者的一个明显的区别。")]),_._v(" "),t("p",[_._v("主键值不要过大，因为所有的普通索引都引用主索引，索引本身是占内存的，若是索引过大，这样就会大大影响查询的效率。")])])}),[],!1,null,null,null);v.default=a.exports}}]);