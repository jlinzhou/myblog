(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{397:function(t,v,_){"use strict";_.r(v);var p=_(24),e=Object(p.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指针"}},[t._v("#")]),t._v(" 指针")]),t._v(" "),_("p",[t._v("指针就是地址。指针变量就是存储地址的变量。")]),t._v(" "),_("p",[t._v("*p:解引用、间接引用。")]),t._v(" "),_("p",[t._v("栈帧：用来给函数运行提供内存空间。取内存于stack上。")]),t._v(" "),_("p",[t._v("​\t\t\t当函数调用时，产生栈帧。函数调用结束，释放栈帧。")]),t._v(" "),_("p",[t._v("​\t\t\t栈帧存储：1.局部变量。2形参。（形参与局部变量存储地位等同）3.内存字段描述值")]),t._v(" "),_("p",[t._v("指针使用注意：")]),t._v(" "),_("p",[t._v("​\t空指针：未被初始化的指针。var p *int    *p--\x3eerr")]),t._v(" "),_("p",[t._v("​\t野指针：被一片无效的地址空间初始化。")]),t._v(" "),_("p",[t._v("申请的内存空间在栈上会自动释放，在堆上不会自动释放,new创建的是在堆上。")]),t._v(" "),_("p",[t._v("格式化输出：")]),t._v(" "),_("p",[t._v("​\t%q:以Go语言格式显示字符串。默认带有“”符")]),t._v(" "),_("p",[t._v("​\t%v:显示对应数据详细信息")]),t._v(" "),_("p",[t._v("变量存储：")]),t._v(" "),_("p",[t._v("​\t等号 左边的变量，代表变量所指向的内存空间")]),t._v(" "),_("p",[t._v("​\t等号 右边的变量， 代表变量内存空间存储的数据值")]),t._v(" "),_("p",[t._v("指针的函数传参：")]),t._v(" "),_("p",[t._v("​\t传地址（引用）：将地址值作为函数参数，返回后传递。")]),t._v(" "),_("p",[t._v("​\t传值（数据）：将实参的值拷贝一份给形参。")]),t._v(" "),_("p",[t._v("​\t传引用：在A栈帧内部，修改B栈帧中的变量值")]),t._v(" "),_("h2",{attrs:{id:"切片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#切片"}},[t._v("#")]),t._v(" 切片")]),t._v(" "),_("p",[t._v("​\t为什么用切片：")]),t._v(" "),_("p",[t._v("​\t\t1.数组的容量固定，不能自动拓展。")]),t._v(" "),_("p",[t._v("​\t\t2.值传递，数组作为函数参数时，将整个数组值拷贝一份给形参。")]),t._v(" "),_("p",[t._v("​\t\t在Go语言中。我们几乎可以在所有场景中，使用切片替换数组使用。")]),t._v(" "),_("p",[t._v("​\t切片的本质，不是一个数组的指针，是一种数据结构，用来操作数组内部元素.")]),t._v(" "),_("p",[t._v("​\t\truntime/slice.go  type  slice struct { *p len cap }")]),t._v(" "),_("p",[t._v("​\t切片的使用：")]),t._v(" "),_("p",[t._v("​\t\t数组和切片定义区别：")]),t._v(" "),_("p",[t._v("​\t\t\t创建数组时[]指定数组长度。")]),t._v(" "),_("p",[t._v("​\t\t\t创建切片时，[]为空，或者...")]),t._v(" "),_("p",[t._v("​\t\t切片名称[low:high:max]")]),t._v(" "),_("p",[t._v("​\t\tlow:起始下标位置")]),t._v(" "),_("p",[t._v("​\t\thigh:结束下标位置 len=high-low")]),t._v(" "),_("p",[t._v("​\t\t容量：cap=max-low  是从它的第一个元素开始数，到其底层数组元素末尾的个数 。")]),t._v(" "),_("p",[t._v("​\t\t截取数组，初始化切片时，切片容量跟随原数组。")]),t._v(" "),_("p",[t._v("​\t\ts[:high:max]:从0开始，到high结束。（不包含）")]),t._v(" "),_("p",[t._v("​\t\ts[low:]:从low开始，到末尾")]),t._v(" "),_("p",[t._v("​\t\ts[:high]:从0开始，到high结束。容量跟随原先容量。【常用】")]),t._v(" "),_("p",[t._v("​\t切片创建：")]),t._v(" "),_("p",[t._v("​\t\t1.自动推导类型创建切片。slice:=[]int{1,2,3,4}")]),t._v(" "),_("p",[t._v("​\t\t2.slice:=make([]int,长度，容量)")]),t._v(" "),_("p",[t._v("​\t\t3.slice:=make([]int,长度)创建切片时，没有指定容量，容量==长度")]),t._v(" "),_("p",[t._v("​\t\t"),_("strong",[t._v("注意：make只能创建slice、map和channel，并且返回一个有初始值（非零）的对象")])]),t._v(" "),_("p",[t._v("​\t切片做函数参数---传引用。（传地址）")]),t._v(" "),_("p",[t._v("​\tappend:")]),t._v(" "),_("p",[t._v("​\t\t向切片增加元素时，切片的容量会自动增长。1024以下时，以两倍方式增长。")]),t._v(" "),_("p",[t._v("​\tcopy:")]),t._v(" "),_("p",[t._v("​\t\tcopy(目标位置切片，源切片)，拷贝过程中，直接对应位置拷贝")]),t._v(" "),_("p",[t._v("​\t\tcopy(data[idx:],data[idx+1:]) return data[:len(data)-1]")]),t._v(" "),_("h2",{attrs:{id:"map"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" map")]),t._v(" "),_("p",[t._v("字典、映射   key-value  key:唯一、无序。不能是引用类型数据。")]),t._v(" "),_("p",[t._v("​\tmap不能使用cap()")]),t._v(" "),_("p",[t._v("​\t创建方式：")]),t._v(" "),_("p",[t._v("​\t\t1.var m1 map[int]string  ---不能存储数据")]),t._v(" "),_("p",[t._v("​\t\t2.m2:=map[int]string --能存储数据")]),t._v(" "),_("p",[t._v("​\t\t3.m3:=make(map[int]string)--默认len=0")]),t._v(" "),_("p",[t._v("​\t\t4.m4:=make(map[int]string,10)")]),t._v(" "),_("p",[t._v("​\t删除map:")]),t._v(" "),_("p",[t._v("​\t\tdelete()函数")]),t._v(" "),_("p",[t._v("​\tstrings.Fields()将字符串拆分成字符串切片")]),t._v(" "),_("h2",{attrs:{id:"结构体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[t._v("#")]),t._v(" 结构体")]),t._v(" "),_("p",[t._v("​\t是一种数据类型")]),t._v(" "),_("p",[t._v("普通变量定义和初始化")]),t._v(" "),_("p",[t._v("​\t\t1.顺序初始化：依次将结构体内部成员初始化。")]),t._v(" "),_("p",[t._v("​\t\t2.制定成员初始化。---未初始化的成员变量，取该数据类型对应得默认值")]),t._v(" "),_("p",[t._v("​\t结构体变量的比较和赋值：")]),t._v(" "),_("p",[t._v("​\t\t1.比较：只能使用==和!= 不能使用> < >= <=")]),t._v(" "),_("p",[t._v("​\t\t2.相同结构体类型(成员变量的类型、个数、顺序一致)变量之间可以直接赋值。")]),t._v(" "),_("p",[t._v("​\t结构体地址：")]),t._v(" "),_("p",[t._v("​\t\t结构体变量的地址==结构体首个元素的地址。")]),t._v(" "),_("p",[t._v("​\t结构体传参：")]),t._v(" "),_("p",[t._v("​\t\tunSafe.Sizeof(变量名)----\x3e此种类型的变量所占用内存空间的大小")]),t._v(" "),_("p",[t._v("​\t\t将结构体变量的值拷贝一份，传参。--几乎不用，内存消耗大，效率低。")]),t._v(" "),_("p",[t._v("指针变量定义和初始化：")]),t._v(" "),_("p",[t._v("​\t\t1.顺序初始化：依次将结构体内部所有成员初始化。")]),t._v(" "),_("p",[t._v("​\t\t2.new(person)")]),t._v(" "),_("p",[t._v("​\t结构体地址：")]),t._v(" "),_("p",[t._v("​\t\t结构体变量的地址==结构体首个元素的地址。")]),t._v(" "),_("p",[t._v("​\t结构体指针传参：")]),t._v(" "),_("p",[t._v("​\t\tunSafe.Sizeof(指针)：不管何种类型的指针，在64位操作系统下，大小一致，均为8字节。")]),t._v(" "),_("p",[t._v("​\t\t将结构体变量的地址值，传递（传引用）。---使用频率非常高！！！")]),t._v(" "),_("p",[t._v("​\t结构体指针做函数返回值：")]),t._v(" "),_("p",[t._v("​\t\t不能返回局部变量的地址值。------局部变量保存在栈帧上，函数调用结束后，栈帧释放，局部变量的地址，不再受系统保护，随时可能分配给其他程序。")]),t._v(" "),_("p",[t._v("​\t\t可以返回局部变量的值。")]),t._v(" "),_("h2",{attrs:{id:"字符串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),_("p",[t._v('​\t1.字符串分割 strings.Split("1.2.3",".")')]),t._v(" "),_("p",[t._v('​\t2.字符串以空格分割strings.Fileds("")')]),t._v(" "),_("p",[t._v('​\t3.判断字符串结束标记HasSuffix   strings.HasSuffix("test.abc","abc")')]),t._v(" "),_("p",[t._v('​\t4.判断字符串起始标记HasPrefix  strings.HasPrefix("test.abc","test")')]),t._v(" "),_("h2",{attrs:{id:"文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件"}},[t._v("#")]),t._v(" 文件")]),t._v(" "),_("p",[t._v("​\t打开创建文件:")]),t._v(" "),_("p",[t._v("​\t\t1.创建文件 Create:文件不存在，文件存在，将文件清空。")]),t._v(" "),_("p",[t._v("​\t\t\t\t参数:name ，打开文件的路径：绝对路径、相对路径")]),t._v(" "),_("p",[t._v("​\t\t2.打开文件Open: 以只读文件打开。")]),t._v(" "),_("p",[t._v("​\t\t\t\t参数:name ，打开文件的路径：绝对路径、相对路径")]),t._v(" "),_("p",[t._v("​\t\t3.打开文件OpenFile:以只读，只写、读写方式打开。")]),t._v(" "),_("p",[t._v("​\t\t\t\t参1：name ，打开文件的路径：绝对路径、相对路径")]),t._v(" "),_("p",[t._v("​\t\t\t\t参2：打开文件权限：O_RDONLY、O_WRONLY 、O_RDWR")]),t._v(" "),_("p",[t._v("​\t\t\t\t参3:一般传6/7")]),t._v(" "),_("p",[t._v("​\t写文件：")]),t._v(" "),_("p",[t._v("​\t\t按字符串写：WriteString()--\x3en个写入的字符个数")]),t._v(" "),_("p",[t._v("​\t\t\t"),_("strong",[t._v("回车换行：windows:\\r\\n   linux:\\n")])]),t._v(" "),_("p",[t._v("​\t\t按位置写")]),t._v(" "),_("p",[t._v("​\t\t\tSeek():修改文件的读写指针位置。")]),t._v(" "),_("p",[t._v("​\t\t\t参1：偏移量。正：向文件尾偏。负：向文件头偏。")]),t._v(" "),_("p",[t._v("​\t\t\t参2：偏移量起始位置。")]),t._v(" "),_("p",[t._v("​\t\t\t\tio.SeekStart  文件起始位置")]),t._v(" "),_("p",[t._v("​\t\t\t\tio.SeekCurrent  文件当前位置")]),t._v(" "),_("p",[t._v("​\t\t\t\tio.SeekEnd  文件结尾位置")]),t._v(" "),_("p",[t._v("​\t\t\t返回值:表示文件起始位置，到文件读写指针位置的偏移量。")]),t._v(" "),_("p",[t._v("​\t\t\toff,_:=f.Seek(-5,io.SeekEnd)")]),t._v(" "),_("p",[t._v("​\t\t按字节写")]),t._v(" "),_("p",[t._v("​\t\t\tWriteAt():在文件指定偏移位置写入[]byte，通常搭配Seek()")]),t._v(" "),_("p",[t._v("​\t\t\t参1：待写入的数据")]),t._v(" "),_("p",[t._v("​\t\t\t参2：偏移量")]),t._v(" "),_("p",[t._v("​\t\t\t返回值：写入文件的字节数")]),t._v(" "),_("p",[t._v('​\t\t\tn,_=f.WriteAt([]byte("111"),off)')]),t._v(" "),_("p",[t._v("​\t读文件：")]),t._v(" "),_("p",[t._v("​\t\t"),_("strong",[t._v("按行读(常用)")])]),t._v(" "),_("p",[t._v("​\t\t\t1.创建一个带有缓冲区的Reader(读写器)")]),t._v(" "),_("p",[t._v("​\t\t\t\treader:=bufio.NewReader(打开的文件指针)")]),t._v(" "),_("p",[t._v("​\t\t\t2.从reader的缓冲区中，读取指定长的数据，数据的长度取决于参数dlime")]),t._v(" "),_("p",[t._v("​\t\t\t\tbuf,err:=reader.ReadBytes('\\n')按行读。")]),t._v(" "),_("p",[t._v("​\t\t\t\t判断到达文件末尾:  if err!=nil && err== io.EOF  到文件结尾。")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\t文件结束标记，是要单独读一次获取到的。")]),t._v(" "),_("p",[t._v("​\t\t\t"),_("strong",[t._v("缓存区：内存中的一块区域，用来减少物理硬盘访问操作")]),t._v("。<<计算硬件及组成原理>>---机械工业出版社")]),t._v(" "),_("p",[t._v("​\t按字节读写文件。")]),t._v(" "),_("p",[t._v("​\t\tread():按字节读文件")]),t._v(" "),_("p",[t._v("​\t\twrite()：按字节写文件")]),t._v(" "),_("p",[t._v("​\t目录操作：")]),t._v(" "),_("p",[t._v("​\t\t打开目录：OpenFile")]),t._v(" "),_("p",[t._v("​\t\t\t参1：name ，打开目录的路径：绝对路径、相对路径")]),t._v(" "),_("p",[t._v("​\t\t\t参2：打开目录权限：O_RDONLY、O_WRONLY 、O_RDWR")]),t._v(" "),_("p",[t._v("​\t\t\t参3:os.ModeDir")]),t._v(" "),_("p",[t._v("​\t\t返回值：返回一个可以读写目录的指针")]),t._v(" "),_("p",[t._v("​\t\t读目录：Readdir")]),t._v(" "),_("h2",{attrs:{id:"并行并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行并发"}},[t._v("#")]),t._v(" 并行并发")]),t._v(" "),_("p",[t._v("​\t并行：在同一时刻，有多条指令在多个处理器上同时执行。\t借助多核cpu实现    (真  并行)")]),t._v(" "),_("p",[t._v("​\t并发：在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行。")]),t._v(" "),_("p",[t._v("​\t\t宏观：用户体验上，程序在并行执行。")]),t._v(" "),_("p",[t._v("​\t\t微观：多个计划任务，顺序执行，在飞快的切换。轮换使用cpu时间轮换。  (假 并行)")]),t._v(" "),_("p",[t._v("​\t进程并发：")]),t._v(" "),_("p",[t._v("​\t\t程序：编译成功得到的二进制文件。 占用磁盘空间。 死的  1")]),t._v(" "),_("p",[t._v("​\t\t进程：运行起来的程序。占用系统资源。（内存）      活的  N")]),t._v(" "),_("p",[t._v("​\t进程状态：")]),t._v(" "),_("p",[t._v("​\t\t初始态、就绪态、运行态、挂起（阻塞）态、终止（停止）态。")]),t._v(" "),_("p",[t._v("​\t孤儿进程:\t父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。")]),t._v(" "),_("p",[t._v("​\t僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程.")]),t._v(" "),_("h3",{attrs:{id:"线程并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程并发"}},[t._v("#")]),t._v(" 线程并发")]),t._v(" "),_("p",[t._v("​\tLWP  **轻量级的进程 **，在linux依然是进程。  **最小的执行单位 **。----cpu分配时间轮片的对象。")]),t._v(" "),_("p",[t._v("​\t进程： **最小的系统资源分配单位。 **")]),t._v(" "),_("p",[t._v("​\t目的是为了并行的争夺cpu，提高cpu执行速度。")]),t._v(" "),_("p",[t._v("​\t同步：")]),t._v(" "),_("p",[t._v("​\t\t协同步调，规划先后顺序。")]),t._v(" "),_("p",[t._v("​\t\t线程同步机制：")]),t._v(" "),_("p",[t._v("​\t\t\t互斥锁(互斥量)：建议锁，拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待，等到锁的线程释放锁。")]),t._v(" "),_("p",[t._v("​\t\t\t读写锁：一把锁（读属性、写属性）。写独占，读共享。写锁优先级高。")]),t._v(" "),_("h3",{attrs:{id:"协程并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协程并发"}},[t._v("#")]),t._v(" 协程并发")]),t._v(" "),_("p",[t._v("​\t协程，coroutine， **轻量级线程。 **")]),t._v(" "),_("p",[t._v("​\tpython、lua、Ruset...")]),t._v(" "),_("p",[t._v("​\t21世纪。")]),t._v(" "),_("p",[t._v("​\t目的是为了程序的执行效率。在阻塞等待期间可以做其他的事情。")]),t._v(" "),_("p",[t._v("总结：进程、线程、协程都可以完成并发。")]),t._v(" "),_("p",[t._v("​\t\t\t稳定性强、节省资源、效率高。")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("h3",{attrs:{id:"goroutine-go程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#goroutine-go程"}},[t._v("#")]),t._v(" Goroutine:go程")]),t._v(" "),_("p",[t._v("并不是由操作系统调度的 ， 避免了上下文切换的额外耗费")]),t._v(" "),_("p",[_("strong",[t._v("奉行通过通信来共享内存，而不是通过共享内存来通信")])]),t._v(" "),_("p",[t._v("​\t创建于进程中。直接使用go关键字，放置于函数调用前面，产生一个go程，并发。")]),t._v(" "),_("p",[t._v("​\tgoroutine的特性：")]),t._v(" "),_("p",[t._v("​\t\t主go程结束，子go程随之退出。")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​\truntime包")]),t._v(" "),_("p",[t._v("​\t\truntime.Gosched():出让当前go程所占用的cpu时间片。当再次获得cpu时，从出让位置继续恢复执行。")]),t._v(" "),_("p",[t._v("​\t\t----时间片轮转调度算法。")]),t._v(" "),_("p",[t._v("​\t\truntime.Goexit():")]),t._v(" "),_("p",[t._v("​\t\t\treturn:返回m8当前函数调用到调用者那里去，return之前的defer注册生效。")]),t._v(" "),_("p",[t._v("​\t\t\tGoexit:退出当前go程。结束调用该函数的当前go程，goexit()之前注册的defer都生效。")]),t._v(" "),_("p",[t._v("​\t\truntime.GOMAXPROCS():设置可以并行计算的cpu核数的最大值，并返回之前的值。")]),t._v(" "),_("p",[t._v("=========")]),t._v(" "),_("p",[t._v("[补充知识点]")]),t._v(" "),_("p",[t._v("​\t每当有一个进程启动时，系统会自动打开三个文件：标准输入、标准输出、标准错误。-----对应三个文件stdin、stdout、stderr。当进程运行结束，操作系统自动关闭三个文件。")]),t._v(" "),_("h3",{attrs:{id:"channel"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[t._v("#")]),t._v(" channel")]),t._v(" "),_("p",[t._v("​\t\t是一种数据类型，对应一个“管道”。")]),t._v(" "),_("p",[t._v("​\t\tchannel的定义：")]),t._v(" "),_("p",[t._v("​\t\t\tmake（chan 在channel中传递的数据类型，容量)  容量=0：无缓冲；容量>0，有缓冲channel。")]),t._v(" "),_("p",[t._v("​\t\t\te.g. make(chan int)或make(chan string ,0)")]),t._v(" "),_("p",[t._v("​\t\tlen(ch)读取channel剩余读取数据的个数，cap(ch)通道的容量。")]),t._v(" "),_("p",[t._v("​\t无缓冲channel:----同步通信")]),t._v(" "),_("p",[t._v("​\t\t通道容量为0，len=0.不能存储数据。")]),t._v(" "),_("p",[t._v("​\t\tchannel应用于两个go程中。一个读，另一个写。")]),t._v(" "),_("p",[t._v("​\t\t具备同步的能力。读写同步。")]),t._v(" "),_("p",[t._v("​\t有缓冲channel----异步通信")]),t._v(" "),_("p",[t._v("​\t\t通道容量为非0.")]),t._v(" "),_("p",[t._v("​\t\tchannel应用于两个go程中。一个读，另一个写。")]),t._v(" "),_("p",[t._v("​\t关闭channel")]),t._v(" "),_("p",[t._v("​\t\t确定不再向对端发送数据，使用close(ch)来关闭channel")]),t._v(" "),_("p",[t._v("​\t\t对端可以判断channel是否关闭")]),t._v(" "),_("p",[t._v("​\t\t\tif num,ok:=<-ch;ok{}")]),t._v(" "),_("p",[t._v("​\t\t\t可以使用range替换ok")]),t._v(" "),_("p",[t._v("​\t\t总结：1.数据不发送完，不应该关闭")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t2.已经关闭的channel，不能再向其写入数据。")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t3.写端已经关闭channel，可以从中读取数据，读到0.----说明：写端关闭.")]),t._v(" "),_("p",[t._v("​\t\t单向channel:")]),t._v(" "),_("p",[t._v("​\t\t\t默认的channel是双向的. var ch chan int   ch=make(chan int)")]),t._v(" "),_("p",[t._v("​\t\t\t单向写channel：var sendCh chan<-int   sendCh=make(chan<-int)不能读操作")]),t._v(" "),_("p",[t._v("​\t\t\t单向读channel:   var recvCh <-chan int   recvCh=make(<-chan int)")]),t._v(" "),_("p",[t._v("​\t\t\t转换：")]),t._v(" "),_("p",[t._v("​\t\t\t\t1.双向channel可以隐式转换为任意一种单向channel")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\tsendCh=ch")]),t._v(" "),_("p",[t._v("​\t\t\t\t2.单向channel不能转换为双向channel")]),t._v(" "),_("p",[t._v("​\t\t\t\t\tch=sendCh    error!")]),t._v(" "),_("p",[t._v("​\t\t\t\t"),_("strong",[t._v("传参，传引用")])]),t._v(" "),_("p",[t._v("​\t生产者消费者模型")]),t._v(" "),_("p",[t._v("​\t\t生产者：")]),t._v(" "),_("p",[t._v("​\t\t消费者：")]),t._v(" "),_("p",[t._v("​\t\t缓冲区：1.解耦（降低生产者和消费者之间的耦合度）")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t2.并发 (生产者消费者数量不对等时，能保持正常通信)")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t3.缓存 (生产者和消费者数据处理速度不一致时，暂存数据)")]),t._v(" "),_("p",[t._v("​\ttime  sleep()  After() NewTimer() NewTicker()")]),t._v(" "),_("p",[t._v("​\t定时器")]),t._v(" "),_("p",[t._v("​\t\tTimer:创建定时器，指定定时时长，定时到达后。系统会自动向定时器的成员C写系统当前时间。")]),t._v(" "),_("p",[t._v("​\t\ttime.After()")]),t._v(" "),_("p",[t._v("​\t\ttime.NewTimer()")]),t._v(" "),_("p",[t._v("​\t\t定时器的停止、重置：")]),t._v(" "),_("p",[t._v("​\t\t\t1)创建定时器myTimer:=time.NewTimer(2*time.Second)")]),t._v(" "),_("p",[t._v("​\t\t\t2)停止：myTimer.Stop  ---将定时器归零.  <-myTimer.C会阻塞")]),t._v(" "),_("p",[t._v("​\t\t\t3)重置：myTimer.Reset(time.Second)")]),t._v(" "),_("p",[t._v("​\t\ttime.Stop()设置定时器停止")]),t._v(" "),_("p",[t._v("​\t\ttime.Reset()定时器重置")]),t._v(" "),_("p",[t._v("select    其中case语句里必须是一个IO操作。一般不写default，避免忙轮询。")]),t._v(" "),_("p",[t._v("​\t作用：用来监听channel上的数据流动方向。读？写？")]),t._v(" "),_("p",[t._v("​\t用法：参考switch case语句。但case后面必须是IO操作，不可以任意写判别表达式。")]),t._v(" "),_("p",[t._v("​\t注意事项：")]),t._v(" "),_("p",[t._v("​\t\t1.监听的case中，没有满足监听条件，阻塞。")]),t._v(" "),_("p",[t._v("​\t\t2.监听的case中，有多个满足监听条件，任选一个执行。")]),t._v(" "),_("p",[t._v("​\t\t3.可以使用default来处理所有case都不满足监听条件的状况。通常不用（会产生忙轮询）")]),t._v(" "),_("p",[t._v("​\t\t4.select自身不带有循环机制，需借助外层for来循环监听。")]),t._v(" "),_("p",[t._v("​\t\t5.break只能跳出select，类似于switch中的用法。")]),t._v(" "),_("p",[t._v("死锁：")]),t._v(" "),_("p",[t._v("​\t1.单go程自己死锁")]),t._v(" "),_("p",[t._v("​\t\tchannel应该在至少2个以上的go程中进行通信，否则死锁。")]),t._v(" "),_("p",[t._v("​\t2.go程间channel访问顺序导致死锁")]),t._v(" "),_("p",[t._v("​\t\t使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁")]),t._v(" "),_("p",[t._v("​\t3.多go程，多channel交叉死锁")]),t._v(" "),_("p",[t._v("​\t\tAgo程，掌握M的同时，尝试N；Bgo程，掌握N的同时尝试拿M.")]),t._v(" "),_("p",[t._v("​\t4.在go语言中，尽量不要将互斥锁、读写锁与channel混用。----隐性死锁")]),t._v(" "),_("p",[t._v("互斥锁：（互斥量）")]),t._v(" "),_("p",[t._v("​\tA、 B  go程共同访问共享数据。由于cpu调度随机，需要对共享数据访问顺序加以限定（同步）。")]),t._v(" "),_("p",[t._v("​\t创建mutex(互斥锁)，访问共享数据之前，加锁，访问结束，解锁。在Ago程加锁期间。Bgo程加锁会失败---阻塞。直至Ago程解锁mutex，B从阻塞处，恢复执行。")]),t._v(" "),_("p",[t._v("读写锁：")]),t._v(" "),_("p",[t._v("​\t读时共享，写时独占。写锁优先级比读锁高。")]),t._v(" "),_("p",[t._v("条件变量：sync.Cond")]),t._v(" "),_("p",[t._v("​\t本身不是锁!经常要与锁结合使用!!")]),t._v(" "),_("p",[t._v("​\t使用流程：")]),t._v(" "),_("p",[t._v("​\t1.创建条件变量： var cond   sync.Cond")]),t._v(" "),_("p",[t._v("​\t2.指定条件变量用的锁  conL=new(sync.Mutex)")]),t._v(" "),_("p",[t._v("​\t3.cond.L.Lock()  给公共区加锁（互斥量）")]),t._v(" "),_("p",[t._v("​    4.判断是否到达阻塞条件（缓冲区满/空）---for 循环判断")]),t._v(" "),_("p",[t._v("​\t\t\tfor len(ch)==cap(ch) {  cond.Wait()   ----1) } 阻塞   2）解锁  3)加锁")]),t._v(" "),_("p",[t._v("​\t5.访问公共区----读、写数据、打印")]),t._v(" "),_("p",[t._v("​\t6.解锁条件变量用的锁 cond.L.Unlock()")]),t._v(" "),_("p",[t._v("​\t7.唤醒阻塞在条件变量上的对端。signal()  Broadcast()")]),t._v(" "),_("h2",{attrs:{id:"网络通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络通信"}},[t._v("#")]),t._v(" 网络通信")]),t._v(" "),_("p",[t._v("​\t协议：一组规则。要求使用协议的双方，必须严格遵守协议内容。")]),t._v(" "),_("p",[t._v("​\t网络分层架构：")]),t._v(" "),_("p",[t._v("​\t\tOSI/RM（理论上的标准）应用层 表示层 会话层 传输层  网络层  数据链路层  物理层（物数网传会表应）")]),t._v(" "),_("p",[t._v("​\t\tTCP/IP(事实上的标准)应用层  传输层  网络层  链路层(链网传应)")]),t._v(" "),_("p",[t._v("​\t\t越往右的层，越靠近硬件；越往左的层，越靠近用户。")]),t._v(" "),_("p",[t._v("​\t各层功能：")]),t._v(" "),_("p",[t._v("​\t\t链路层：ARP")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t源MAC----目标MAC")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\tARP协议作用：借助IP获取mac地址")]),t._v(" "),_("p",[t._v("​\t\t网络层：IP")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t源IP-----目标IP")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\tIP协议的作用：在网络环境中唯一标识一台主机")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\tIP地址本质：2进制数。-----点分十进制IP地址（string)")]),t._v(" "),_("p",[t._v("​\t\t传输层：TCP/UDP")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\tport----在一台主机上唯一标识一个进程。")]),t._v(" "),_("p",[t._v("​\t\t应用层：ftp、http、自定义")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t对数据进行封装、解封装")]),t._v(" "),_("p",[t._v("数据通信过程：")]),t._v(" "),_("p",[t._v("​\t封装：应用层----传输层----网络层----链路层")]),t._v(" "),_("p",[t._v("​\t解封装：链路层---网络层----传输层-----应用层")]),t._v(" "),_("p",[t._v("总结通信过程：")]),t._v(" "),_("p",[t._v("​\t1.mac地址（不需要用户指定）  （ARP协议）ip-------\x3emac")]),t._v(" "),_("p",[t._v("​\t2.IP地址（需要用户指定）-----确定主机")]),t._v(" "),_("p",[t._v("​\t3.port端口号（需要用户指定）----确定程序")]),t._v(" "),_("p",[t._v("​\t\t\t1.不能使用系统占用的默认端口。5000+端口我们使用（8080）")]),t._v(" "),_("p",[t._v("​\t\t\t2.65535为端口上限")]),t._v(" "),_("p",[t._v("socket编程：(双向全双工)")]),t._v(" "),_("p",[t._v("​\t网络通信过程中：socket一定是成对出现的。")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("网络设计模式：")]),t._v(" "),_("p",[t._v("​\tC/S：")]),t._v(" "),_("p",[t._v("​\t\t优点：数据传输效率高，协议选择灵活。")]),t._v(" "),_("p",[t._v("​\t\t缺点：工作量大，安全性构成威胁。")]),t._v(" "),_("p",[t._v("​\tB/S:")]),t._v(" "),_("p",[t._v("​\t\t优点：开发工作较小，不受平台限制，安全威胁小。")]),t._v(" "),_("p",[t._v("​\t\t缺点：缓存数据差，协议选择不灵活。")]),t._v(" "),_("p",[t._v("TCP-CS客户端：")]),t._v(" "),_("p",[t._v('​\t1.conn,err:=net.Dial("TCP",服务器的IP+port)')]),t._v(" "),_("p",[t._v("​\t2.写数据的服务器conn.Write()")]),t._v(" "),_("p",[t._v("​\t3.读取服务器回发的数据conn.Read()")]),t._v(" "),_("p",[t._v("​\t4.conn.Close()")]),t._v(" "),_("p",[t._v("TCP-CS并发服务端：")]),t._v(" "),_("p",[t._v('​\t1.创建监听套接字listener:=net.Listen("tcp",服务器的IP+port)')]),t._v(" "),_("p",[t._v("​\t2.defer listener.Close()")]),t._v(" "),_("p",[t._v("​\t3.for 循环阻塞监听客户端连续事件 conn:=listen.Accept()")]),t._v(" "),_("p",[t._v("​\t4.创建go程对应每一个客户端进行数据通信 go HandlerConnect()")]),t._v(" "),_("p",[t._v("​\t5.实现HandlerConnect(conn net.Conn)")]),t._v(" "),_("p",[t._v("​\t\t\t1)defer conn.Close()")]),t._v(" "),_("p",[t._v("​\t\t\t2)获取成功连接的客户端Addr    conn.RemoteAddr()")]),t._v(" "),_("p",[t._v("​\t\t\t3)for  循环  读取客户端发送数据  conn.Read(buf)")]),t._v(" "),_("p",[t._v("​\t\t\t4)处理数据 小----大")]),t._v(" "),_("p",[t._v("​\t\t\t5)回写转换后的数据  conn.Write(buf[:n])")]),t._v(" "),_("p",[t._v("服务器判断关闭：")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("read读客户端，返回0----对端关闭!")])]),t._v(" "),_("p",[t._v("三次握手")]),t._v(" "),_("p",[t._v("​\t客户端主动发起连接请求端，标志位SYN  2000(0),被动接收连接请求端，请求端回复ACK  2001和SYN 7000(0)，客户端回复ACK 7001  三次握手完成---连接建立完成.")]),t._v(" "),_("p",[t._v("​\t1.主动发起请求端，发送SYN")]),t._v(" "),_("p",[t._v("​\t2.被动建立连接请求端，应答ACK同时发送SYN")]),t._v(" "),_("p",[t._v("​\t3.主动发起请求端，发送应答ACK")]),t._v(" "),_("p",[t._v("​\t标志TCP三次握手建立完成.---server.Accept()返回。  ----client.Dial()返回")]),t._v(" "),_("p",[t._v("四次挥手(因为半关闭)")]),t._v(" "),_("p",[t._v("​\t客户端主动发出关闭请求，标志位FIN 2000(0) ，被动关闭连接请求端，回复ACK 2001，这时主动关闭端处于半关闭，被动关闭连接请求端再次回复FIN  5000(0)，主动关闭端回复ACK 5001 ,四次挥手完成.")]),t._v(" "),_("p",[t._v("​\t1.主动关闭连接请求端，发送FIN")]),t._v(" "),_("p",[t._v("​\t2.被动关闭连接请求端，应答ACK      标志。半关闭完成。-----close()(服务端)")]),t._v(" "),_("p",[t._v("​\t3.被动关闭连接请求端，发送FIN")]),t._v(" "),_("p",[t._v("​\t4.主动关闭请求端，应答ACK   标志。四次挥手建立完成----close()（客户端）")]),t._v(" "),_("ul",[_("li",[t._v("封装：通过方法实现")]),t._v(" "),_("li",[t._v("继承：通过匿名字段实现")]),t._v(" "),_("li",[t._v("多态：通过接口实现")])]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("p",[t._v("​")])])}),[],!1,null,null,null);v.default=e.exports}}]);