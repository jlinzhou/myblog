(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{430:function(n,e,t){"use strict";t.r(e);var o=t(24),s=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v('函数\nmap ,省去了写for循环过程\nfilter\nre.findall(规则，str)\nlambda为匿名函数 ,a省去了定义函数\nextend可以将另一个集合中的元素逐一添加到列表中\nlist.sort(reverse=False)排序\nraise抛出异常\nrandom.random()生成0-1之间的随机小数\nres=str.count("aa")统计计数\nzip()打包为元组的列表\nGIL 是python的全局解释器锁')]),n._v(" "),t("p",[n._v("注意点\nlist删除用remove\nb=[j for j in a]  对象用一行转为列表\nn=''.join(list)   列表转为字符串\njson.dumps()字典转json字符串，json.loads()json转字典\nsorted有返回值，sort无返回值")]),n._v(" "),t("p",[n._v("常见问题\n__new__和__init__区别")]),n._v(" "),t("p",[n._v("python传参数是传值还是传址\n如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。\n如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。")]),n._v(" "),t("p",[n._v("提高python运行效率的方法\n1、使用生成器，因为可以节约大量内存\n列表生成式的[]改成()，就创建了一个generator\n2、循环代码优化，避免过多重复代码的执行\n减少时间复杂度\n3、核心模块用Cython PyPy等，提高效率\nCPython：是用C语言实现Pyhon.\n4、多进程、多线程、协程\n5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率")]),n._v(" "),t("p",[n._v("分别从前端、后端、数据库阐述web项目的性能优化\n前端优化：\n1、减少http请求、例如制作精灵图\n2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差\n后端优化：\n1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。\n2、异步方式，如果有耗时操作，可以采用异步，比如celery\n3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况\n数据库优化：\n1、如有条件，数据可以存放于redis，读取速度快\n2、建立索引、外键等")]),n._v(" "),t("p",[n._v("python中copy和deepcopy区别\n1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。\n2、复制的值是可变对象（列表和字典）\n浅拷贝copy有两种情况：\n第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。\n第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值 ，会影响浅复制的值。\n深拷贝deepcopy：完全复制独立，包括内层列表和字典\n3.\n而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。\n浅拷贝：共享内存，传引用\n深拷贝：新开辟内存")]),n._v(" "),t("p",[n._v("czce白糖和dce豆粕")])])}),[],!1,null,null,null);e.default=s.exports}}]);