---
title: 事务
---

### 事务的基本要素(ACID)

1. 原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行
2. 一致性(Consistency)：事务开始前和结束后，数据库的完整性约束没有被破坏。
3. 隔离性(Isolation)：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
4. 持久性(Durability)：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

### 事务的并发问题

1. **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. **不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. **幻读**：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。

### MySQL事务隔离级别

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 是   | 是         | 是   |
| 读已提交     | 否   | 是         | 是   |
| 可重复读     | 否   | 否         | 是   |
| 串行化       | 否   | 否         | 否   |

在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。 通过索引加锁，间隙锁，next key lock可以解决幻读的问题。（即加共享锁lock in share mode或排他锁 for update）



可重复读是 MySQL InnoDB 引擎的默认隔离级别，但是在 MySQL 额外添加了间隙锁（Gap Lock），可以防止幻读。

### Mysql的逻辑结构

- 最上层的服务类似其他**CS结构**，比如连接处理，授权处理。
- 第二层是**Mysql的服务层**，包括SQL的解析分析优化，存储过程触发器视图等也在这一层实现。
- 最后一层是**存储引擎的实现**，类似于Java接口的实现，Mysql的执行器在执行SQL的时候只会关注API的调用，完全屏蔽了不同引擎实现间的差异。比如Select语句，先会判断当前用户是否拥有权限，其次到缓存（内存）查询是否有相应的结果集，如果没有再执行解析sql，优化生成执行计划，调用API执行。



### SQL执行顺序

SQL的执行顺序：from---where--group by---having---select---order by



### MVCC简介

1. 什么是MVCC
   MVCC是一种**多版本并发控制机制**。

2. MVCC是为了解决什么问题?
   大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用.
   大家都应该知道,**锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.**

3. MVCC实现
   **MVCC是通过保存数据在某个时间点的快照来实现的**. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有**乐观并发控制和悲观并发控制**。在Mysql的InnoDB引擎中就是指在**已提交读**(READ COMMITTD)和**可重复读**(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。 

4. MVCC 具体实现分析
   下面,我们通过InnoDB的MVCC实现来分析MVCC使怎样进行并发控制的. 
   InnoDB的MVCC，是通过在每行记录后面保存**两个隐藏的列**来实现的.

     1.DATA_TRX_ID表示最近修改该行数据的**事务ID **

     2.DATA_ROLL_PTR则表示指向**该行回滚段的指针**，该行上所有旧的版本，在undo中都通过链表的形式组织，而该值，正式指向undo中该行的历史记录链表 

   (这两个列，分别保存了这个行的**创建时间**，一个保存的是行的**删除时间**。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.下面看一下在REPEATABLE READ隔离级别下,MVCC具体是如何操作的.)

   

   原文链接：https://blog.csdn.net/whoamiyang/article/details/51901888



**undoLog** 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚 

 **redoLog** 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中 

 **binlog**由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑 



### InnoDB的行锁模式

​	共享锁为读锁，只用于表级 ，本次事务可以读不能写，其他事务只能读。 lock in share mode.

​	排他锁为写锁， 用于行级 ，本次事务可以读可以写，其他事务增删改查都不行。 for update .

### Mysql如何保证一致性和持久性

MySQL为了保证ACID中的一致性和持久性，使用了WAL(Write-Ahead Logging,**先写日志再写磁盘**)。Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新Redo log就足够了。

### 为什么选择B+树作为索引结构

- Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于**区间查询是无法直接通过索引查询的**，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种**多路平衡查询树，所以他的节点是天然有序的**（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
- 二叉查找树：**解决了排序的基本问题**，但是由于**无法保证平衡**，可能退化为链表。
- 平衡二叉树：**通过旋转解决了平衡的问题**，但是**旋转操作效率太低**。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了	**AVL旋转效率过低**的问题，但是在磁盘等场景下，**树仍然太高，IO次数太多**。
- B+树：在B树的基础上，将**非叶节点改造为不存储数据纯索引节点**，进一步**降低了树的高度**；此外将**叶节点使用指针连接成链表**，范围查询更加高效。



### B+树的叶子节点都可以存哪些东西

(可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引)

### 覆盖索引

指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

 **索引包含所有满足查询需要的数据的索引 **

### 查询在什么时候不走（预期中的）索引

​	like、不等于、参与计算、对null判断、or没有索引、查询集过大、非最左前缀

1. 模糊查询 %like
2. 索引列参与计算,使用了函数
3. 非最左前缀顺序
4. where对null判断
5. where不等于
6. or操作有至少一个字段没有索引
7. 需要回表的查询结果集过大（超过配置的范围）

###  什么是最左前缀原则
MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：
```mysql
select * from user where name=xx and city=xx ; ／／可以命中索引

select * from user where name=xx ; // 可以命中索引

select * from user where city=xx ; // 无法命中索引
````

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

### 数据库优化指南

1. 创建并使用正确的索引
2. 只返回需要的字段
3. 减少交互次数（批量提交）
4. 设置合理的Fetch Size（数据每次返回给客户端的条数）





### 索引类型

**从逻辑角度**

1、**主键索引**：主键索引是一种特殊的唯一索引，不允许有空值 ADD PRIMARY KEY  

2、普通索引或者**单列索引**

 ADD INDEX index_name ( column )  
 唯一任务是加快对数据的访问速度

3、联合索引 ADD INDEX index_name ( )

联合索引，对多个字段同时建立索引，最左前缀原则

4、**唯一索引**

ADD UNIQUE 
不允许两行具有相同的索引值 

 **主键索引和唯一索引的区别：**
(1) 对于主键/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；
(2) 主键不一定只包含一个字段，所以在主键的其中一个字段建`唯一索引`还是有必要的；
(3) 主键`可作外键`，唯一索引不可；
(4) 主键`不可为空`，唯一索引可；
(5) 主键`可是多个字段的组合`；
(6) 主键与唯一索引不同的是：
a.有`not null`属性；
b.每个表`只能有一个`。
(7) 主键索引一定是唯一索引， `唯一索引不是主键索引`
(8) 主键`可以与外键 构成 参照完整性约束`， `防止数据不一致` 

### MongoDB的使用场景

 MongoDB目前只支持单文档事务，需要复杂事务支持的场景暂时不适合；只支持行级的事务，或者说支持原子性，单行的操作要么全部成功，要么全部失败。 

 MongoDB的使用场景：
 1.敏捷开发。新应用，需求会变，适合字段变动很多的业务，数据模型无法确定，想快速迭代开发，MongoDB没有固定的Schema，所有花在提交、沟通和实施Schema变更的时间都生下来了。
 2.不需要事务及复杂 join 支持,例如日志等
 3.更高的写入负载
  MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。本身存的就是json格式数据。例如做日志系统。
 4.数据量很大或者将来会变得很大
  Mysql单表数据量达到5-10G时会出现明显的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展，MongoDB内建了sharding、很多数据分片的特性，容易水平扩展，比较好的适应大数据量增长的需求。
 5.NoSQL适合存储非结构化数据，如文章、评论
 6.高可用性
  自带高可用，自动主从切换（副本集） 

