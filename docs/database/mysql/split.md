---
title: 分表分库
---

## 分库分表前的问题

任何问题都是太大或者太小的问题，我们这里面对的数据量太大的问题。

### 用户请求量太大

因为单服务器TPS，内存，IO都是有限的。 解决方法：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。

### 单库太大

单个数据库处理能力有限；单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈 解决方法：切分成更多更小的库

### 单表太大

CRUD都成问题；索引膨胀，查询超时 解决方法：切分成多个数据集更小的表





### 垂直拆分

拆分字段

 1.垂直分表 

 2.垂直分库

### 水平拆分

拆分数据

   1.水平分表

2. 水平分库分表 



# 水平分库分表切分规则 

HASH取模

一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。

### 路由

通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id mod 4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id mod 4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 mod 4后确定记录在User_0003中



# 分库分表存在的问题

**1 事务问题。**

在执行分库分表之后，由于数据存储到了不同的库上，**数据库事务管理出现了困难**。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的***\*性能代价\****；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。

**2 跨库跨表的join问题。**

在执行了分库分表之后，难以避免会将原本**逻辑关联性很强的数据划分到不同的表、不同的库上**，这时，表的关联操作将受到限制，我们**无法join位于不同分库的表**，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要**多次查询**才能完成。

**3 额外的数据管理负担和数据运算压力。**

额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。



**4 数据库自增 id**

这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。